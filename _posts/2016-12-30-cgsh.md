---
layout: post
title:  "CGsh"
date:   2019-04-26
excerpt: "A Command-line Shell for Combinatorial Graph Applications"
project: true
tags: [cgsh, shell, graph]
comments: false
---

![Euler's Dilemma](/assets/img/konigsberg.jpeg)
    
<center><b>Euler's Dilemma:</b> The Seven Bridges of KÃ¶nigsberg.</center>


Back in December 2016, when I was eager to start my journey into Computer Science, one topic interested me in particular - Combinatorial Graphs. I had the good fortune of working with Prof. Rupesh Nasre of the Indian Institute of Technology, Madras throughout the duration of the project.   

## The Idea

Just before I started working on this project, I had gone through [this excellent blog post](https://brennan.io/2015/01/16/write-a-shell-in-c/) on the implementation of a very basic shell in C. This motivated Prof. Nasre and myself to work on a shell for combinatorial graph applications. Some important points we had in mind were:

1. The interface had to be clean and clear, with no ambiguity for users. 
2. For the shell to actually be useful, it had to be capable of working on existing graphs. The shell interface had to be able to read a file with information about nodes and/or edges of the graph in a particular format and perform various operations on it.
3. Finally, it had to be extensible.

## The Process

I started working on the project in C. However, we soon realized that performing memory allocation operations using the `malloc` function was neither feasible nor scalable. I moved to C++ and started using the STL for dynamic data structures. Using C++ also gave me the additional advantage of approaching the problem with an object-oriented approach. The entire shell interface, along with definitions for graph data structures and algorithms is contained in four files, with code being appropriately distributed.

The core data structure definitions and function prototypes are all contained in the `graph.cpp` file. The core functionality is contained in the `graph` class. 

```cpp
class graph {
	private:
		// V denotes vertices, and E denotes Edges
		int vertices, edges;
		// Instead of a linked list, I decided to use a two dimensional vector of the node
		// structure I created above. Avoiding pointers makes the code less prone
		// to errors and NULL references.
		adjList adj;

	public:
		void addEdge(int, int);
		void addEdge(int, int, int);
		void addEdgeFromFile(int, int);
		void addEdgeFromFile(int, int, int);
		graph(int);
		graph(int, int);
		graph(std::string);
		int nVertices();
		int nEdges();
		int nNeighbours(int);
		list adjVertices(int);
		bool vertexCheck(int);
		bool edgeCheck(int, int);
		void print();
		void deleteEdge(int, int);
		std::vector<int> verticesList(void);
		bool weightedChecker();
		void randomWeightGenerator();
};
```

